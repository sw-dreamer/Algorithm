# 라빈-카프 알고리즘 (Rabin-Karp Algorithm)

라빈-카프 알고리즘은 문자열 검색 알고리즘으로, 주어진 텍스트에서 특정 패턴을 빠르게 찾을 수 있는 방법입니다.

이 알고리즘은 **해시 함수**를 사용하여 텍스트와 패턴의 해시 값을 비교함으로써, 패턴이 텍스트에 존재하는지 효율적으로 검사합니다.

일반적으로 라빈-카프 알고리즘은 **문자열 매칭**에서 **O(n)**의 시간 복잡도를 가질 수 있지만, 해시 충돌이 발생할 경우 최악의 경우 **O(n * m)**의 시간 복잡도가 될 수 있습니다.

여기서 `n`은 텍스트의 길이, `m`은 패턴의 길이입니다.

### 라빈-카프 알고리즘의 기본 아이디어

1. **해시 함수 사용**:
   - 텍스트의 각 부분 문자열과 패턴에 대해 해시 값을 계산합니다. 이 해시 값들이 동일하면 해당 부분 문자열과 패턴이 일치하는지 확인합니다.
   - 해시 충돌을 피하기 위해, 정확한 문자열 비교를 하기 전에 해시 값이 일치하는지 먼저 확인합니다.

2. **슬라이딩 윈도우**:
   - 텍스트를 왼쪽에서 오른쪽으로 한 글자씩 슬라이드 하며 각 부분 문자열에 대해 해시 값을 계산합니다. 이를 통해 텍스트에서 패턴을 효율적으로 검색합니다.

---

## 라빈-카프 알고리즘의 동작 과정

1. **패턴과 텍스트의 해시 값 계산**:
   - 텍스트와 패턴에 대해 각 부분 문자열의 해시 값을 계산합니다. 이때 해시 함수는 일반적으로 **문자열을 정수로 변환**하는 방식으로 사용됩니다.

2. **슬라이딩 윈도우를 사용한 검색**:
   - 텍스트에서 길이가 패턴과 동일한 부분 문자열을 슬라이딩 윈도우 방식으로 순차적으로 검사합니다. 각 부분 문자열의 해시 값을 계산하고, 해시 값이 일치하면 실제 문자열을 비교하여 패턴이 일치하는지 확인합니다.

---

## 해시 함수 예시

라빈-카프 알고리즘에서 사용하는 **해시 함수**는 주어진 문자열 `S`에 대해 다음과 같이 정의됩니다:

$$
\text{hash}(S) = (S[0] \times d^{(m-1)} + S[1] \times d^{(m-2)} + \dots + S[m-1] \times d^0) \mod q
$$

여기서:

- `S[i]`는 문자열 `S`의 `i`번째 문자입니다.
- `d`는 사용되는 문자 집합의 크기입니다. 일반적으로 아스키 문자 집합을 사용할 경우 `d = 256`입니다.
- `m`은 문자열의 길이입니다.
- `q`는 소수로, 해시 값을 계산할 때 사용하는 모듈러 연산의 기준이 됩니다.

### 해시 함수 계산 예시

예를 들어, 문자열 `S = "AB"`에 대해 해시 값을 계산한다고 합시다.

1. 문자 `'A'`는 아스키 값으로 `65`이고, 문자 `'B'`는 `66`입니다.
2. `d = 256`, `q = 101`, `m = 2` (문자열 길이)일 경우,
   
   해시 값은 다음과 같이 계산됩니다:

$$
\text{hash}("AB") = (65 \times 256^{(2-1)} + 66 \times 256^{(2-2)}) \mod 101
$$

즉,

$$
\text{hash}("AB") = (65 \times 256 + 66 \times 1) \mod 101 = (16640 + 66) \mod 101 = 16706 \mod 101 = 67
$$

이와 같이 해시 함수는 문자열의 각 문자를 특정 기준에 따라 가중치를 부여하고, 이를 모두 더한 후 소수 `q`로 나누어 결과를 구합니다. 이 값이 바로 문자열 `S`의 해시 값입니다.

---

## 라빈-카프 알고리즘의 장단점

### 단점
- **효율성**: 해시 값을 사용하여 텍스트에서 패턴을 빠르게 검색할 수 있습니다.
- **여러 패턴 검색 가능**: 라빈-카프 알고리즘은 텍스트에서 여러 패턴을 동시에 검색하는 데 적합합니다.

### 단점

- **해시 충돌**: 해시 값이 동일하지만 실제 문자열이 다른 경우가 있을 수 있습니다. 이를 해결하기 위해 해시 충돌을 처리하는 추가적인 기법이 필요합니다.
- **최악의 경우 성능 저하**: 해시 충돌이 많을 경우, 문자열 비교를 추가적으로 수행해야 하므로 **O(n * m)**의 시간 복잡도가 될 수 있습니다.

---

## 라빈-카프 알고리즘의 시간 복잡도
  - 해시 값 계산: 각 문자의 해시 값을 계산하는 데 O(1) 시간이 걸리고, 텍스트에서 각 부분 문자열을 비교하는 데 O(n) 시간이 걸립니다.
  - 최악의 경우: 해시 충돌이 많으면 실제 문자열 비교를 수행해야 하므로 O(n * m) 시간이 걸릴 수 있습니다.

    따라서 라빈-카프 알고리즘의 평균 시간 복잡도는 **O(n + m)**이지만, 최악의 경우에는 **O(n * m)**이 될 수 있습니다.
