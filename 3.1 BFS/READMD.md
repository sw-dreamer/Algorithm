# BFS (Breadth-First Search) 알고리즘

## 1. BFS란 무엇인가?

BFS(너비 우선 탐색, **Breadth-First Search**)는 그래프나 트리에서 데이터를 탐색하는 알고리즘입니다.

BFS는 "너비 우선"이라는 이름처럼, 시작 노드에서 가까운 노드부터 차례대로 탐색을 진행합니다.

이를 통해 최단 경로를 찾는 데 유용하게 사용될 수 있습니다.

BFS는 **선입선출 원칙** 으로 탐색하는 방식으로 **큐(Queue)** 를 주로 사용하여 코드를 작성합니다. 

### BFS의 특징
- **레벨 단위 탐색**: BFS는 먼저 시작 노드를 방문하고, 그 노드와 연결된 노드들을 탐색한 뒤, 그 다음 단계로 넘어갑니다.
- **큐(Queue) 사용**: BFS는 큐 자료구조를 사용하여 탐색을 진행합니다. 큐는 선입선출(FIFO) 방식으로 동작하므로, 먼저 큐에 들어간 노드부터 탐색합니다.

## 2. BFS 알고리즘 동작 과정

BFS 알고리즘은 다음과 같은 방식으로 작동합니다:

1. **시작 노드를 큐에 넣는다**.
2. 큐에서 하나씩 노드를 꺼내며 그 노드와 연결된 인접한 노드들을 큐에 넣는다.
3. 각 노드는 한 번만 방문하고, 방문한 노드는 다시 방문하지 않도록 처리한다.
4. 큐가 비어 있을 때까지 이 과정을 반복한다.

![sw_dreamer_bfs](https://github.com/user-attachments/assets/d32e7108-68a6-4638-a0f9-e8d14fb8250d)

- 시작 노드: Ø (노드 0)
- 인접 노드들:
  - Ø -> 1, 2
  - 1 -> 3, 4
  - 2 -> 5, 6

## BFS 알고리즘 순서

1. **시작 노드 선택**: BFS는 시작 노드에서부터 탐색을 시작합니다. 이 예제에서는 노드 0 (Ø)부터 시작합니다.

2. **큐 초기화**: 시작 노드인 `0`을 큐에 넣습니다.
   - 큐: `[0]`

3. **큐에서 노드 꺼내기**: 큐에서 첫 번째 노드인 `0`을 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `0`
   - 인접 노드: `1`, `2`
   - 큐에 `1`과 `2`를 추가합니다.
   - 큐: `[1, 2]`

4. **큐에서 노드 꺼내기**: 큐에서 `1`을 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `1`
   - 인접 노드: `3`, `4`
   - 큐에 `3`과 `4`를 추가합니다.
   - 큐: `[2, 3, 4]`

5. **큐에서 노드 꺼내기**: 큐에서 `2`를 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `2`
   - 인접 노드: `5`, `6`
   - 큐에 `5`와 `6`을 추가합니다.
   - 큐: `[3, 4, 5, 6]`

6. **큐에서 노드 꺼내기**: 큐에서 `3`을 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `3`
   - 인접 노드: `1` (이미 방문한 노드이므로 큐에 추가하지 않습니다.)
   - 큐: `[4, 5, 6]`

7. **큐에서 노드 꺼내기**: 큐에서 `4`을 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `4`
   - 인접 노드: `1` (이미 방문한 노드이므로 큐에 추가하지 않습니다.)
   - 큐: `[5, 6]`

8. **큐에서 노드 꺼내기**: 큐에서 `5`을 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `5`
   - 인접 노드: `2` (이미 방문한 노드이므로 큐에 추가하지 않습니다.)
   - 큐: `[6]`

9. **큐에서 노드 꺼내기**: 큐에서 `6`을 꺼내고, 그 노드의 인접 노드를 탐색합니다.
   - 현재 노드: `6`
   - 인접 노드: `2` (이미 방문한 노드이므로 큐에 추가하지 않습니다.)
   - 큐: `[]`

10. **탐색 종료**: 큐가 비면 BFS 탐색이 종료됩니다.

## BFS 탐색 순서

탐색 순서는 다음과 같습니다:
Ø -> 1 -> 2 -> 3 -> 4 -> 5 -> 6

## 3. BFS 알고리즘의 시간 복잡도

BFS 알고리즘의 시간 복잡도는 그래프의 **정점(Vertex)** 수 `V`와 **간선(Edge)** 수 `E`에 비례합니다. 즉, BFS의 시간 복잡도는 `O(V + E)`입니다. 

- **정점** `V`: 그래프에서의 노드의 개수.
- **간선** `E`: 그래프에서의 간선(노드 간 연결)의 개수.

BFS는 각 노드를 한 번만 방문하며, 각 간선도 한 번만 검사합니다. 따라서 시간 복잡도는 그래프의 크기에 비례합니다.

## 4. BFS 알고리즘에서 사용하는 자료구조

BFS 알고리즘에서 주로 사용하는 자료구조는 **큐(Queue)**입니다. 큐는 선입선출(FIFO) 방식으로 작동하며, 탐색할 노드를 순차적으로 처리하는 데 적합합니다. 큐를 이용하여 현재 노드를 방문하고, 그 노드와 연결된 노드를 큐에 넣어 차례대로 탐색을 진행합니다.

## 5. BFS 활용 예시

BFS는 다양한 문제에서 활용됩니다. 대표적인 활용 예시는 다음과 같습니다:

### 1) **최단 경로 문제**
BFS는 **무방향 그래프**에서 시작 노드로부터 다른 노드까지의 최단 경로를 찾는 데 사용됩니다. BFS는 가장 가까운 노드부터 탐색하므로, 최단 경로를 찾는 데 유리합니다.

### 2) **그래프의 연결 요소 찾기**
그래프가 여러 개의 연결된 부분으로 나뉘어 있을 때, BFS를 이용해 각 연결 요소를 찾을 수 있습니다. 이를 통해 그래프가 연결된 부분을 분리하여 탐색할 수 있습니다.

### 3) **미로 탐색**
미로에서 출구까지의 최단 경로를 찾을 때, BFS를 사용하여 미로의 각 위치를 탐색하면서 최단 경로를 계산할 수 있습니다. BFS는 인접한 위치부터 차례대로 탐색하므로, 출구에 도달하는 최소 경로를 구할 수 있습니다.

### 4) **그래프의 레벨 탐색**
BFS는 그래프의 각 레벨을 탐색하는 데 유용합니다. 예를 들어, 트리에서 특정 노드로부터 다른 노드까지의 거리를 계산하거나, 친구 관계와 같이 레벨별로 관계를 분석할 때 사용될 수 있습니다.

## 6. BFS의 장점과 단점

### 장점
- **최단 경로**: BFS는 최단 경로를 찾는 데 매우 유용합니다. 무방향 그래프에서 시작 노드로부터 다른 노드까지의 최단 경로를 보장합니다.
- **레벨 단위 탐색**: BFS는 노드를 레벨 단위로 탐색하므로, 특정 레벨에 있는 노드를 한 번에 처리할 수 있습니다.

### 단점
- **메모리 소모**: BFS는 큐를 사용하여 탐색하므로, 그래프의 크기가 크거나 복잡한 경우 많은 메모리를 필요로 할 수 있습니다.
- **간선이 많은 그래프에서 비효율적**: 간선의 수가 매우 많은 그래프에서는 BFS가 비효율적일 수 있습니다. 이 경우, 다른 탐색 알고리즘을 고려할 수 있습니다.

## 7. 결론

BFS(너비 우선 탐색)는 그래프나 트리에서 효과적으로 데이터를 탐색하는 알고리즘으로, 특히 최단 경로 문제를 해결하는 데 유용합니다. 큐를 사용하여 각 노드를 탐색하며, 레벨 단위로 탐색을 진행합니다. 다양한 문제에서 활용될 수 있으며, 특히 그래프나 트리의 구조를 이해하는 데 중요한 알고리즘입니다.

