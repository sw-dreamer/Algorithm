# Java 알고리즘 종류

이 문서에서는 Java에서 자주 사용되는 알고리즘들을 소개합니다. 각 알고리즘의 특징과 시간 복잡도, 장단점 등을 포함하여 그 용도와 구현 방식을 간단히 설명합니다.

## 1. 정렬 알고리즘 (Sorting Algorithms)

정렬 알고리즘은 데이터를 일정한 순서로 배열하는 알고리즘입니다.

### 1.1 버블 정렬 (Bubble Sort)
- **설명**: 인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 방식으로 정렬합니다.
- **시간 복잡도**: O(n²)
- **장점**: 
  - 구현이 간단하고 직관적입니다.
  - 데이터가 이미 정렬되어 있으면 빠르게 종료됩니다.
- **단점**:
  - 시간 복잡도가 O(n²)로 비효율적입니다.
  - 대규모 데이터에 적합하지 않습니다.

### 1.2 선택 정렬 (Selection Sort)
- **설명**: 배열에서 가장 작은 원소를 찾아서 앞쪽에 놓는 방식입니다.
- **시간 복잡도**: O(n²)
- **장점**: 
  - 구현이 간단합니다.
  - 데이터의 크기가 작을 때 유용할 수 있습니다.
- **단점**:
  - 시간 복잡도가 O(n²)로 비효율적입니다.
  - 안정적인 정렬이 아닙니다.

### 1.3 삽입 정렬 (Insertion Sort)
- **설명**: 배열을 순차적으로 탐색하면서, 각 원소를 이미 정렬된 부분에 적절한 위치에 삽입합니다.
- **시간 복잡도**: 평균 O(n²), 최선 O(n)
- **장점**: 
  - 이미 정렬된 배열에서는 매우 효율적입니다.
  - 배열을 정렬하는 중간에 다른 배열과 합칠 수 있습니다.
- **단점**:
  - 최악의 경우 시간 복잡도가 O(n²)로 비효율적입니다.

### 1.4 병합 정렬 (Merge Sort)
- **설명**: 배열을 절반으로 나누어 정렬하고, 다시 합쳐서 정렬하는 방식입니다.
- **시간 복잡도**: O(n log n)
- **장점**:
  - 항상 O(n log n)의 성능을 보입니다.
  - 안정적인 정렬이 가능합니다.
- **단점**:
  - 추가적인 메모리가 필요합니다 (O(n) 공간 복잡도).
  - 작은 데이터에 비효율적일 수 있습니다.

### 1.5 힙 정렬 (Heap Sort)
- **설명**: 이진 힙 구조를 이용해 정렬하는 알고리즘입니다.
- **시간 복잡도**: O(n log n)
- **장점**:
  - 최악의 경우에도 O(n log n)의 성능을 보입니다.
  - 공간 복잡도가 O(1)로 효율적입니다.
- **단점**:
  - 안정적인 정렬이 아닙니다.
  - 구현이 다소 복잡할 수 있습니다.
 
### 1.6 분할 정복 (Divide and Conquer)

분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하고, 그 결과를 결합하여 전체 문제를 해결하는 기법입니다.

### 1.6.1 퀵 정렬 (Quick Sort)
- **설명**: 분할 정복 방식의 정렬 알고리즘입니다.
- **장점**: 평균적으로 매우 빠릅니다.
- **단점**: 최악의 경우 성능이 나쁩니다.

### 1.6.2 병합 정렬 (Merge Sort)
- **설명**: 분할 정복 방식의 정렬 알고리즘입니다.
- **장점**: 항상 O(n log n) 성능을 보입니다.
- **단점**: 추가적인 메모리가 필요합니다.


## 2. 탐색 알고리즘 (Searching Algorithms)

탐색 알고리즘은 데이터 구조 내에서 특정 값을 찾는 방법을 제공합니다.

### 2.1 선형 탐색 (Linear Search)
- **설명**: 배열을 처음부터 끝까지 순차적으로 탐색합니다.
- **시간 복잡도**: O(n)
- **장점**:
  - 구현이 간단하고 직관적입니다.
  - 데이터가 정렬되지 않아도 사용할 수 있습니다.
- **단점**:
  - 데이터가 많을수록 비효율적입니다.

### 2.2 이진 탐색 (Binary Search)
- **설명**: 정렬된 배열에서 중간값을 기준으로 절반씩 나누어가며 탐색합니다.
- **시간 복잡도**: O(log n)
- **장점**:
  - 매우 빠르게 탐색을 할 수 있습니다.
  - 큰 데이터에서 효율적입니다.
- **단점**:
  - 배열이 정렬되어 있어야 하므로, 정렬이 되어 있지 않으면 사용할 수 없습니다.

## 3. 그래프 알고리즘 (Graph Algorithms)

그래프는 노드(정점)와 간선(엣지)으로 구성된 자료구조입니다.

### 3.1 너비 우선 탐색 (BFS, Breadth-First Search)
- **설명**: 그래프의 노드를 층별로 탐색합니다. 큐를 사용합니다.
- **시간 복잡도**: O(V + E)
- **장점**:
  - 최단 경로를 찾는 데 유용합니다.
  - 그래프의 모든 노드를 탐색할 수 있습니다.
- **단점**:
  - 큐를 사용하므로 추가적인 메모리가 필요합니다.
  - 깊이 우선 탐색에 비해 성능이 떨어질 수 있습니다.

### 3.2 깊이 우선 탐색 (DFS, Depth-First Search)
- **설명**: 그래프를 깊이 우선으로 탐색합니다. 스택을 사용합니다.
- **시간 복잡도**: O(V + E)
- **장점**:
  - 메모리 사용이 적고, 구현이 간단합니다.
  - 경로를 추적하거나 연결 요소를 찾을 때 유용합니다.
- **단점**:
  - 경우에 따라 불필요한 경로를 탐색할 수 있습니다.
  - 최단 경로를 찾는 데 적합하지 않습니다.

### 3.3 다익스트라 알고리즘 (Dijkstra's Algorithm)
- **설명**: 가중치가 있는 그래프에서 최단 경로를 찾는 알고리즘입니다.
- **시간 복잡도**: O(V²) 또는 힙을 사용할 경우 O((V + E) log V)
- **장점**:
  - 가중치가 있는 그래프에서 최단 경로를 찾는 데 매우 효율적입니다.
- **단점**:
  - 음수 가중치가 있을 경우 사용할 수 없습니다.

### 3.4 벨만-포드 알고리즘 (Bellman-Ford Algorithm)
- **설명**: 음의 가중치를 가진 그래프에서도 최단 경로를 구할 수 있는 알고리즘입니다.
- **시간 복잡도**: O(VE)
- **장점**:
  - 음수 가중치가 있는 그래프에서도 동작합니다.
- **단점**:
  - 시간 복잡도가 O(VE)로 상대적으로 느립니다.

### 3.5 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)
- **설명**: 모든 노드 간의 최단 경로를 구하는 알고리즘입니다.
- **시간 복잡도**: O(V³)
- **장점**:
  - 모든 노드 간의 최단 경로를 구할 수 있습니다.
- **단점**:
  - 시간 복잡도가 O(V³)로 큰 그래프에서는 비효율적입니다.

## 4. 동적 계획법 (Dynamic Programming)

동적 계획법은 문제를 작은 하위 문제로 나누어 푸는 기법입니다.

### 4.1 피보나치 수열 (Fibonacci Sequence)
- **설명**: 재귀적으로 계산되는 피보나치 수열을 동적 계획법을 통해 효율적으로 계산하는 방법입니다.
- **장점**: 중복 계산을 방지하여 효율성을 높입니다.
- **단점**: 하위 문제의 수가 매우 많으면 메모리 사용이 커질 수 있습니다.

### 4.2 배낭 문제 (Knapsack Problem)
- **설명**: 주어진 물건들을 가방에 담을 때 최대 가치를 구하는 문제입니다.
- **장점**: 최적해를 구할 수 있습니다.
- **단점**: 메모리 사용이 많을 수 있습니다.

### 4.3 최대 부분 수열 합 (Maximum Subarray Sum)
- **설명**: 배열에서 연속된 부분 배열의 합이 최대인 값을 구하는 문제입니다.
- **장점**: 효율적으로 문제를 해결할 수 있습니다.
- **단점**: 복잡한 경우 메모리 사용이 많을 수 있습니다.

## 5. 백트래킹 (Backtracking)

백트래킹은 모든 가능한 해를 탐색하는 방식으로, 중간에 조건이 맞지 않으면 되돌아가서 다른 경로를 탐색하는 알고리즘입니다.

### 5.1 N-Queens 문제
- **설명**: N개의 퀸을 N x N 체스판에 놓을 때, 서로 공격하지 않도록 배치하는 문제입니다.
- **장점**: 문제를 해결하기 위한 모든 경로를 탐색할 수 있습니다.
- **단점**: 최악의 경우, 계산 시간이 매우 길어질 수 있습니다.

### 5.2 부분 집합 생성 (Subset Generation)
- **설명**: 주어진 집합에서 가능한 모든 부분 집합을 생성하는 문제입니다.
- **장점**: 모든 경우의 수를 탐색할 수 있습니다.
- **단점**: 계산 시간이 매우 오래 걸릴 수 있습니다.

## 6. 그리디 알고리즘 (Greedy Algorithms)

그리디 알고리즘은 문제를 풀 때 매 단계에서 최선의 선택을 하는 방식입니다.

### 6.1 활동 선택 문제 (Activity Selection Problem)
- **설명**: 주어진 시간대에 가장 많은 활동을 선택하는 문제입니다.
- **장점**: 구현이 간단하고 효율적입니다.
- **단점**: 항상 최적해를 보장하지 않을 수 있습니다.

### 6.2 허프만 코드 (Huffman Coding)
- **설명**: 데이터를 압축하는 데 사용되는 알고리즘입니다.
- **장점**: 데이터 압축 효율이 높습니다.
- **단점**: 구현이 복잡할 수 있습니다.

## 7. 문자열 알고리즘 (String Algorithms)

문자열 처리와 관련된 다양한 알고리즘들이 있습니다.

### 7.1 KMP 알고리즘 (Knuth-Morris-Pratt)
- **설명**: 패턴 매칭 알고리즘으로, 문자열 내에서 특정 패턴을 빠르게 찾는 방법입니다.
- **장점**: 매우 효율적입니다.
- **단점**: 구현이 복잡할 수 있습니다.

### 7.2 라빈-카프 알고리즘 (Rabin-Karp Algorithm)
- **설명**: 해시 값을 이용한 문자열 검색 알고리즘입니다.
- **장점**: 빠르고 효율적입니다.
- **단점**: 해시 충돌을 처리하는 데 시간이 걸릴 수 있습니다.
