# JAVA 알고리즘

1. DFS
   
<hr/>

# Depth-First Search (DFS)

Depth-First Search (DFS)는 그래프나 트리에서 노드를 탐색하는 알고리즘 중 하나입니다.

DFS는 가능한 한 깊이 탐색을 진행하며, 더 이상 깊이 탐색할 수 없을 때, 다시 되돌아가서 다른 경로를 탐색하는 방식입니다.

DFS는 스택을 사용하거나 재귀를 이용해 구현할 수 있습니다.

## 특징

- **방식**: 깊이를 우선으로 탐색 (하나의 경로를 끝까지 탐색 후 다른 경로로 이동)
- **시간 복잡도**: O(V + E) (V는 노드의 수, E는 간선의 수)
- **공간 복잡도**: O(V) (스택에 저장되는 최대 깊이에 따라 달라짐)
- **구현 방법**: 스택 사용 또는 재귀 함수 사용

## 동작 원리

DFS는 트리 또는 그래프에서 한 노드를 방문하고, 해당 노드의 인접한 노드를 재귀적으로 방문하는 방식입니다.

모든 노드를 방문할 때까지 이 과정을 반복합니다.


### DFS 알고리즘 순서

1. **시작 노드**를 스택에 넣고 방문을 시작합니다.

2. 스택에서 **가장 마지막에 들어온 노드**를 꺼내어 방문합니다.

3. 해당 노드와 인접한 **방문하지 않은 노드들**을 스택에 넣고, 해당 노드를 방문 처리합니다.

4. 스택이 비거나 모든 노드를 방문하면 탐색을 종료합니다.

   ### 예시

   ```
        A
      /   \
     B      C
    / \    / \
   D  E   F   G

   ```
![sw_dreamer_DFS](https://github.com/user-attachments/assets/065b4f11-9688-432c-b35a-8e5425acbff7)

   #### 그래프 구조
    - A는 B와 C로 연결됩니다.
    - B는 D와 E로 연결됩니다.
    - C는 F와 G로 연결됩니다.

   #### DFS 탐색 순서

   - DFS는 A부터 시작해서 B로 이동하고, B에서 가능한 깊이까지 탐색을 진행합니다.
   - 탐색 순서: A → B → D → E → C → F → G
   - 탐색 과정:
        - A에서 시작:
          
          A에서 B로 이동합니다.
          
        - B로 이동:
          
          B에서 D로 이동합니다.
          
        - D를 탐색:
          
          D는 더 이상 연결된 노드가 없으므로, 다시 B로 돌아옵니다.
          
        - E를 탐색:
          
          E를 탐색한 후, 다시 B로 돌아옵니다.
          
        - C를 탐색:
          
          C로 이동한 후, F로 이동합니다.
          
        - F를 탐색:
          
          F를 탐색한 후, G로 이동합니다.
          
        - G를 탐색:
          
          모든 노드를 탐색한 후, DFS는 종료됩니다.
    
## 활용 예시
  - 경로 탐색: 두 지점 간의 경로를 찾을 때 사용됩니다.
  - 그래프의 연결 요소 탐색: 그래프가 연결되어 있는지, 또는 여러 연결 요소가 있는지 탐색하는 데 유용합니다.
  - 미로 탐색: 미로에서 출구를 찾는 문제에 적합합니다.

## DFS의 장단점

### 장점
  - 깊이를 우선으로 탐색하기 때문에, 하나의 경로를 빠르게 끝까지 탐색할 수 있습니다.
  - 메모리 사용이 상대적으로 적습니다 (스택을 사용하는 경우).

### 단점
  - 깊이가 매우 깊은 트리나 그래프에서는 탐색이 비효율적일 수 있습니다.
    
  - 경로를 찾을 때, 특정 조건을 만족하는 경로가 있을 경우, 다른 조건을 만족하는 경로를 찾을 수 있습니다.
    (즉, 최단 경로를 보장하지 않음)

<hr/>
