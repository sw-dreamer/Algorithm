# Depth-First Search (DFS)

**Depth-First Search (DFS)** 는 그래프나 트리에서 노드를 탐색하는 알고리즘 중 하나입니다.
DFS는 가능한 한 깊이 탐색을 진행하며, 더 이상 깊이 탐색할 수 없을 때, 다시 되돌아가서 다른 경로를 탐색하는 방식입니다.
DFS는 **스택**을 사용하거나 **재귀**를 이용해 구현할 수 있습니다.

## 특징

- **방식**: 깊이를 우선으로 탐색 (하나의 경로를 끝까지 탐색 후 다른 경로로 이동)
- **시간 복잡도**: `O(V + E)` (V는 노드의 수, E는 간선의 수)
- **공간 복잡도**: `O(V)` (스택에 저장되는 최대 깊이에 따라 달라짐)
- **구현 방법**: 스택 사용 또는 재귀 함수 사용

## 동작 원리

DFS는 트리 또는 그래프에서 한 노드를 방문하고, 해당 노드의 인접한 노드를 재귀적으로 방문하는 방식입니다. 모든 노드를 방문할 때까지 이 과정을 반복합니다.

### DFS 알고리즘 순서

1. **시작 노드**를 스택에 넣고 방문을 시작합니다.
2. 스택에서 **가장 마지막에 들어온 노드**를 꺼내어 방문합니다.
3. 해당 노드와 인접한 **방문하지 않은 노드들**을 스택에 넣고, 해당 노드를 방문 처리합니다.
4. 스택이 비거나 모든 노드를 방문하면 탐색을 종료합니다.

---

### 예시

![sw_dreamer_DFS](https://github.com/user-attachments/assets/065b4f11-9688-432c-b35a-8e5425acbff7)

#### 그래프 구조
- **A**는 **B**와 **C**로 연결됩니다.
- **B**는 **D**와 **E**로 연결됩니다.
- **C**는 **F**와 **G**로 연결됩니다.

#### DFS 탐색 순서

- DFS는 **A**부터 시작해서 **B**로 이동하고, **B**에서 가능한 깊이까지 탐색을 진행합니다.
- 탐색 순서: `A → B → D → E → C → F → G`

#### 탐색 과정:
1. **A에서 시작**:  
   `A`에서 `B`로 이동합니다.
   
2. **B로 이동**:  
   `B`에서 `D`로 이동합니다.

3. **D를 탐색**:  
   `D`는 더 이상 연결된 노드가 없으므로, 다시 `B`로 돌아옵니다.
   
4. **E를 탐색**:  
   `E`를 탐색한 후, 다시 `B`로 돌아옵니다.
   
5. **C를 탐색**:  
   `C`로 이동한 후, `F`로 이동합니다.
   
6. **F를 탐색**:  
   `F`를 탐색한 후, `G`로 이동합니다.
   
7. **G를 탐색**:  
   모든 노드를 탐색한 후, DFS는 종료됩니다.

---

## 활용 예시

- **경로 탐색**: 두 지점 간의 경로를 찾을 때 사용됩니다.
- **그래프의 연결 요소 탐색**: 그래프가 연결되어 있는지, 또는 여러 연결 요소가 있는지 탐색하는 데 유용합니다.
- **미로 탐색**: 미로에서 출구를 찾는 문제에 적합합니다.

---

## DFS의 장단점

### 장점
- **깊이를 우선으로 탐색**하기 때문에, 하나의 경로를 빠르게 끝까지 탐색할 수 있습니다.
- **메모리 사용이 상대적으로 적음**: 스택을 사용하는 경우, 큐를 사용하는 BFS보다 적은 메모리를 사용합니다.

### 단점
- **깊이가 매우 깊은 트리나 그래프**에서는 탐색이 비효율적일 수 있습니다.
- **최단 경로를 보장하지 않음**: 경로를 찾을 때, 특정 조건을 만족하는 경로가 있을 경우, 다른 조건을 만족하는 경로를 찾을 수 있습니다. DFS는 항상 최단 경로를 보장하지 않습니다.
